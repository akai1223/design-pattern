## 设计模式 design pattern

### 结构模式

##### 适配器模式 adapter
  * 没有层次关系
  * 类适配器模式
    * 继承源对象 实现目标对象接口
  * 对象适配器模式
    * 持有 src类，实现 dst 类接口，完成src->dst的适配。
    * 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。
  * 接口适配器模式
    * 借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取
      得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。
      
##### 装饰器模式 decorator
  * 有层次关系
  * 实现共同接口，继承相同类，扩展功能，内部持有被装饰对象的实例
  * 增强功能 动态添加或覆盖包装者的接口行为
  * 需要扩展一个类的功能，但是又不能修改源代码，动态的为一个对象增加功能，而且还能动态撤销。
  * 角色以及职责
    * Component： 装饰器模式应用的目标组件的抽象
    * Concrete Component： Component 的具体实现
    * Decorator： 装饰器的抽象
    * Concrete Decorator： 装饰器的实现类
  
  ![装饰器模式类图](https://images2017.cnblogs.com/blog/999804/201710/999804-20171027104657695-321042156.png)
  
##### 代理模式 proxy 

  * 使用场景
    * 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
      * 修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
      * 就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
    * 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！