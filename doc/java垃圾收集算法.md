### **1.垃圾对象的判断**

 Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，判定对象是否为垃圾对象有如下算法：

####  (1)：引用计数算法

​    给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器都为0的对象就是不可能再被使用的。

​    引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择，当Java语言并没有选择这种算法来进行垃圾回收，主要原因是它很难解决对象之间的相互循环引用问题。

　看下面代码：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * 虚拟机参数：-verbose:gc
 */
public class ReferenceCountingGC
{
    private Object instance = null;
    private static final int _1MB = 1024 * 1024;
    
    /** 这个成员属性唯一的作用就是占用一点内存 */
    private byte[] bigSize = new byte[2 * _1MB];
    
    public static void main(String[] args)
    {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
        objectA = null;
        objectB = null;
        
        System.gc();
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

看下运行结果：

```
[GC 4417K->288K(61440K), 0.0013498 secs]
[Full GC 288K->194K(61440K), 0.0094790 secs]
```

 

看到，两个对象相互引用着，但是虚拟机还是把这两个对象回收掉了，这也说明虚拟机并不是通过引用计数法来判定对象是否存活的。

#### (2)：可达性分析法（又称根搜索算法）

​    为了克服引用计数法的弊端，现在比较主流的实现算法是可达性分析算法。Java和C#中都是采用根搜索算法来判定对象是否存活的。这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。

具体如图：

![img](https://images2017.cnblogs.com/blog/285952/201711/285952-20171102203139951-1243094054.png)

在Java语言里，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中的常量引用的对象。
- 本地方法栈中JNI（Native方法）的引用对象。

### **2.引用判断过程**

**判断引用是否无效的过程分为三个阶段** 
（1）：当JVM进行垃圾收集时，JVM使用可达性分析算法进行分析，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，此时该对象将被第一次标记，并进行一次筛选，筛选的条件是此对象有没有必要执行finalize()方法，如果对象没有覆盖该方法，或者该方法已经被虚拟机调用过了，虚拟机将这两种情况都视为“没有必要执行”。 
（2）：如果该对象被判定为有必要执行finalize()方法，那么对象将会被放置到一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承若会等待它运行结束。因为一个对象可能在finalize()方法中执行缓慢，或者发生了死循环，这将导致该队列中的其他对象长期处于等待阶段，甚至导致整个内存系统的奔溃。 
（3）：F-Queue中的标记筛选。 
finalize()方法是对象逃脱死亡命运的最后一次机会，然后GC将对F-Queue中的对象进行第二次小规模的标记。如果对象在finalize()方法中成功拯救了自己，即与引用链上的任何一个对象建立关联，那么在第二次标记的时候，该算法将被移出F-Queue的集合，如果对象这个时候还没有逃脱，那基本上它就真的被回收了。

### **3.对象的4种引用状态**

 在JDK1.2之前，Java中引用的定义很传统：如果引用（reference）类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的引用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为**强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）**四种，引用强度依次减弱。

- 强引用：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用：它用来描述一些可能还有用，但并非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference类来表示软引用。
- 弱引用：它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来表示弱引用。
- 虚引用：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。

### **4.方法区回收**

虚拟机规范中不要求方法区一定要实现垃圾回收，而且方法区中进行垃圾回收的效率也确实比较低，但是HotSpot对方法区也是进行回收的，主要回收的是废弃常量和无用的类两部分。判断一个常量是否“废弃常量”比较简单，只要当前系统中没有任何一处引用该常量就好了，但是要判定一个类是否“无用的类”条件就要苛刻很多，类需要同时满足以下三个条件：

1、该类所有实例都已经被回收，也就是说Java堆中不存在该类的任何实例

2、加载该类的ClassLoader已经被回收

3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证方法区不会溢出。

### **5.垃圾收集算法**

目前比较主流的垃圾收集算法有四种：标记-清除算法、复制算法、标记-整理算法、分代收集算法。

#### **（1）：标记-清除（Mark-Sweep）算法**

标记-清除算法最基础的算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。

优点：简单，易于实现。

缺点：主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。

标记-清除算法执行过程如图：

![img](https://images2017.cnblogs.com/blog/285952/201711/285952-20171103100810482-585867576.png)

 

#### **（2）：复制（Copying）算法**

复制算法是为了解决效率问题而出现的，**它将可用的内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉**。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。

优点：内存分配时算法不产生内存碎片。

缺点：空间消耗太大，内存被压缩为原来的一半。

复制算法的执行过程如图：

![img](https://images2017.cnblogs.com/blog/285952/201711/285952-20171103101229904-246339540.png)

现在的商用虚拟机都采用这种算法来**回收新生代**，不过研究表明1:1的比例非常不科学，因此**新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。**每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。

#### **（3）：标记-整理（Mark-Compact）算法**

复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，分为两个过程标记和整理。首先标记出所有需要回收的对象，然后不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。

优点：内存分配时算法不产生内存碎片，也比较易于实现。

缺点：算法复杂度大，执行步骤较多。

标记-整理算法的工作过程如图：

![img](https://images2017.cnblogs.com/blog/285952/201711/285952-20171103101432935-6728666.png)

#### **（4）：分代收集算法**

根据上面的内容，用一张图概括一下堆内存的布局

![img](https://images2015.cnblogs.com/blog/801753/201509/801753-20150924230142897-1555721768.png)

现代商用虚拟机基本都采用**分代收集算法**来进行垃圾回收。这种算法其实是前三种算法的有机结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。一般在Java堆中分为两大块新生代和老年代。

​    **在新生代中**，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法

​    **在老年代中，**因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收*。*